# react_express_prac
### 작동방식
1. crawling 폴더에서 크롤링 후
2. Back 폴더에 위치한 Express 서버를 통해 DB에 데이터를 저장
3. 저장된 데이터를 Front 폴더에서 React 기반 클라이언트에서 Express서버로 요청을 보냄
4. 응답받은 캠페인 데이터를 렌더링

### 사용방법
1. front, back, crawilng 각 폴더에서 npm i 를 CLI에 입력해 node_modules를 설치
2. back/routes/api.js 에서 주석처리된 함수를 주석 해제
3. back 폴더로 들어가 CLI에 npm run dev를 입력하여 서버 실행
4. crawling 폴더의 wadiz.js를 node.js환경에서 실행 (이미 DB에 저장되어있으므로 필수는 아니다)
5. 주석처리 해제했던 함수 다시 주석처리
6. front 폴더에서 CLI에 npm run dev를 입력하여 서버 실행
7. http://127.0.0.1:5173로 접속하여 렌더링 확인

### 느낀점+배운점
1. 크콜링 + 클라이언트 + 서버 이 세 조합은 처음이라 배운게 많았다.
2. 보편적인 RDB에서는 1:N 관계에서 N이 1을 참조하지만, '자기참조'라는 조건이 걸려있었고 Comment 모델에 commentReplys 라는 항목이 필수 조건이었으므로 1이 N을 (댓글이 대댓글들을) 참고하도록 설계했다. 물론 따지고 보면 N이 1을 참조하는게 불가능한 것은 아니다. 양방향 참조도 가능하고, commentReplys를 사용하지 않고 대댓글마다 originalComment와 같은 key로 참조하고 있는 댓글의 _id를 저장하면 가능했다. 하지만 문제에 조건에 가장 잘 맞는 방법이라고 판단되는 방식으로 접근하였다. 이를 위해 사용한 방식은 다음과 같다.
    1. 캠페인을 모두 크롤링하고, DB에 저장한다.
    2. 저장된 캠페인의 id값으로 comment들을 크롤링한다.
    3. comment들이 담긴 comments 배열을 순회하며 각 comment의 commentReplys를 순회한다.
    4. commentReplys에 담긴 대댓글들을 모두 먼저 저장한다. 이때 받은 대댓글의 _id를 원 댓글의 commentReplys에 담아 서버로 전송한다.
3. 자잘한 실수로 인해 시간지연이 발생하였다. mongoose에서 model.find()와 model.findOne()의 차이점을 몰라 약 30분 가량 고전했었다. 또한 Express 서버 api 라우팅 과정에서 '/save/campaign'로 보내고 있는 요청이 몇줄 위에서 작성된 '/:campaignId/comment/:commentId'로 들어가버려 comment가 저장되지 않는 문제도 있었다.
4. GPT를 잘 활용하면 시간을 매우 많이 단축할 수 있다. 그러나 너무 맹신하면 안된다. 아무리 자세히 설명을 해도 잘못된 코드를 작성하거나, 스스로 모순이 있는 답변을 하거나, 종종 잘못된 정보를 준다. 구조를 설계하고 구조의 흐름, 로직을 잘 이해한 후 코드 작성단계 정도에서 활용하면 좋다.
5. 종합적으로 서버와 클라이언트를 직접 구축하여 직접 크롤링한 데이터를 다루면서 REST API체계를 이해하는 것에 그치지 않고 구현할 수 있는 능력을 함양하게 되었다. 또한 서로 다른 서버와의 통신으로 인한 CORS에러 등의 문제를 프록시 또는 CORS 라이브러리로 해결할 수 있는 등 문제해결 능력도 기를 수 있었다.